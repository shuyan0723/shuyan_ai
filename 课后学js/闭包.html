<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>闭包</title>
</head>
<body>
    <script>
        // function outer(){
        //     let a=100
        //     function fn(){
        //     console.log(a);//里层函数加外层函数的变量捆绑到一起就形成了闭包 
        //     }
        //     fn()
        // }
        // outer()
        //  const fun=outer()
        //  fun() //外层函数使用内部函数的变量
        //  常见的闭包形式 外部可以访问使用 函数内部的变量

    //     闭包的作用:实现数据的私有化 函数调用，函数调用一次，就++
    //     普通形式，统计函数调用的次数
        // let i=0
        // function fun2(){
        //     i++
        //     console.log(`函数被调用了${i}次`);
        // }
        // fun2()
        // fun2()
        // i是全局变量，很容易被修改

        // 闭包形式 统计函数调用的次数
        let z;
        function count(){
            let i=0
            function fun(){
                i++
                console.log(`函数被调用了${i}次`);
            }
            return fun;
        }
     z= count();//创建闭包
     z() // 1 使用闭包
     z() // 2
     z() // 3
     z() // 4
     z=null//不需要闭包了，清理它
     z()// 无效

    // //   function noteBookMessage(){
    // //     let Book="这是我的日记"//这是日记的内容
    // //     // 这个函数就像是那个盒子，它能记住Book这个日记
    // //     function showMessage(){
    // //      console.log(Book);
    // //     }
    // //     // 把盒子(函数)给朋友
    // //        return showMessage;
    // //   }
    // //     // 你把盒子给了朋友
    // //   const myBook=noteBookMessage();
      
    // //     // 朋友打开盒子，看到日记
    // //      myBook();// 这是我的日记
    // function outerFunction(){  // 定义外部函数
    // let outerVariable="外部函数的变量" // 外部函数的变量
    // function innerFunction(){  // 定义内部函数
    //     console.log(outerVariable); // 内部函数可以访问外部函数的变量
    // }
    // return innerFunction  // 闭包 外部函数的变量被内部函数引用，形成闭包
    // }
    // const myClosure=outerFunction(); // 调用外部函数，返回闭包
    // myClosure()// 外部函数的变量
    // // outerFunction 定义了一个外部函数的变量outerVariable 和 一个内部函数innerFunction
    // // 内部函数可以访问外部函数的变量，形成闭包
    // // innerFunction 可以访问 outerFunction 定义的变量，形成闭包
    // // 即使outerFunction已经执行完毕
    // // outerFunction返回了innerFunction,将其赋值给了变量myClosure
    // // 当调用myClosure()时，它仍然可以访问outerVariable,形成闭包,这就是闭包的作用
//     function createBigData() {
//   let bigData = new Array(1000000).fill('a'); // 创建一个很大的数组
//   return function() {
//     console.log('闭包函数被调用了');
//   };
// }

// const closure = createBigData();
// closure(); // 调用闭包函数
    </script>
</body>
</html>