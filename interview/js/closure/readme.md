# 介绍下闭包

- 一句话介绍概念
closure是js的重要语法特性，能访问**自由变量**的函数就叫闭包
当一个内部函数访问了它所在的外部函数作用域的变量，即使外部函数已经执行完毕，
这些变量仍然停留在内存中，像在背包一样，供内部函数调用，这种机制叫闭包。

你不知道的JavaScript 闭包=函数 + 词法作用域 （本质）

形成条件： 函数嵌套函数，内部函数可以在外界访问（返回或挂载在全局）
       立即执行函数，块级作用域+定时器

- 底层原理
     词法作用域（Lexical Scope）
     JavaScript在定义函数时，就确定了函数能访问哪些变量（作用域在申明阶段就决定），这个过程叫做词法作用域。
     作用域链（Scope Chain）内部函数在查找变量时会沿着作用域链向上查找外层变量，
     变量的持久化：由于闭包函数依然引用自由变量，JS 引擎的GC（垃圾回收机制）认为
     这些外部变量还在用，所以不会销毁，导致变量值持久存在。

- 模型图

     [Global Scope]
         ^
         |
    [Outer Function Scope]
          ^
          |
    [Inner Function Scope]

- 应用场景

    - 数据私有化
          封装类或函数的复杂性
    - 防抖节流
    - 循环绑定事件
    ````js
    for(var i=0;i<3;i++){
        setTimeout(()=>{
            console.log(i);
        },1000)
    }
    var->let 闭包
    立即执行函数 IIFE
    ````

    - 缓存记忆优化
    函数的缓存，避免重复计算
    ````js
    function memoize(fn){
        const cache={};
        return function(key){
            if(cache[key]){ return cache[key];
            const result=fn(key);
            cache[key]=result;
            return result;
            }
        }
    }
    ````
    - 柯里化
    一个接收多个参数的函数，变成多个接收一个参数的函数链

    - 偏函数....

## 总结

闭包是函数与其外部词法作用域的组合，它让函数在外部作用域执行完后依然能访问里面的变量。
本质是作用域链导致变量持久化，在过程中常用于数据私有化，防抖节流，时间绑定，缓存优化等场景。

我在项目中经常用闭包减少全局变量的使用，避免全局变量的污染。
但也要注意闭包的内存泄漏问题，避免内存泄漏。不需要时手动释放引用

## setTimeout 里的回调函数时闭包吗？穷追猛打
从定义上说，setTimeout的回调一般会形成闭包。因为它在创建的时候捕获了外层函数的变量
即使外层函数执行结束，变量依旧可访问。

但严格来说，setTimeout的回调函数不是闭包，因为它没有捕获外层函数的变量。
闭包的本质是函数+词法环境的绑定。是否是闭包，取决于是否调用自由变量
而不是setTimeout API。

比如在循环定时器的时候用let 声明块级作用域或IIFE 闭包定时器回调，是闭包

